#include "pch"

#ifdef __clang__
#pragma clang diagnostic ignored "-Wcovered-switch-default"
#pragma clang diagnostic ignored "-Wswitch-enum"
#endif

#pragma warning(disable : 4061)

template <usize N, typename mode> struct tensor
{
	mode inner[N];

	mode& operator[](usize i)
	{
		return inner[i];
	}
	const mode& operator[](usize i) const
	{
		return inner[i];
	}
};

template <typename scalar> struct tensor<0, scalar>
{
	scalar value;

	operator scalar&()
	{
		return value;
	}
	operator const scalar&() const
	{
		return value;
	}
};

template <typename of>
concept fp = floating_point<of>;
template <typename of>
concept bits = integral<of>;
template <typename of>
concept number = fp<of> || bits<of>;

template <number repr> using scalar = tensor<0, repr>;

template <usize dimensions, number repr = f32> using vector = tensor<dimensions, scalar<repr>>;

template <usize rows, usize cols = rows, number repr = f32> using matrix = tensor<rows, vector<cols, repr>>;

template <bits data> usize count_leading_zeros(data* value);

extern "C"
{
	// MEMORY
	void* allocate_aligned(usize size, usize alignment)
	{
	}
	void* allocate_any(usize size)
	{
		constexpr usize ALIGN = 16;
		usize align = min(ALIGN, count_leading_zeros(&size));
		return allocate_aligned(size, align);
	}

	void* reallocate(void* old, usize new_size)
	{
	}

	void deallocate(void* ptr)
	{
	}

	// ASYNC
	struct raw_waker;

	typedef struct raw_waker_virtual_table
	{
		void (*clone)(const void* data, raw_waker* out_waker);
		void (*wake)(const void* data);
		void (*wake_by_ref)(const void* data);
		void (*drop)(const void* data);
	} waker_virtual_table;

	struct raw_waker
	{
		const raw_waker_virtual_table* vtable;
		const void* data;
	};

	typedef enum
	{
		POLL_RESULT_READY,
		POLL_RESULT_PENDING
	} poll_result;

	struct task_virtual_table
	{
		poll_result (*poll)(void* task_data, raw_waker* waker);
		void (*drop)(void* task_data);
	};

	using task = void*;
	task task_spawn(task_virtual_table* vtable, void* user_data);

	// INPUT
	enum cursor_mode
	{
		CURSOR_MODE_VISIBLE,
		CURSOR_MODE_HIDDEN,
		CURSOR_MODE_CAPTURED
	};

	enum mouse_button
	{
		MOUSE_BUTTON_LEFT,
		MOUSE_BUTTON_RIGHT,
		MOUSE_BUTTON_MIDDLE
	};

	enum axis
	{
		AXIS_X,
		AXIS_Y,
		AXIS_Z,
	};

	enum gamepad_button
	{
		GAMEPAD_BUTTON_DOWN,
		GAMEPAD_BUTTON_RIGHT,
		GAMEPAD_BUTTON_UP,
		GAMEPAD_BUTTON_LEFT,
		GAMEPAD_BUTTON_RIGHT_STICK,
		GAMEPAD_BUTTON_LEFT_STICK,
		GAMEPAD_BUTTON_RIGHT_BUMPER,
		GAMEPAD_BUTTON_LEFT_BUMPER
	};

	enum gamepad_analog
	{
		GAMEPAD_ANALOG_LEFT_STICK,
		GAMEPAD_ANALOG_RIGHT_STICK,
		GAMEPAD_ANALOG_LEFT_TRIGGER,
		GAMEPAD_ANALOG_RIGHT_TRIGGER
	};

	using scan_code = u16;

	enum button_state
	{
		DOWN,
		UP,
		PRESS,
		TAP
	};

	bool input_scan(scan_code key, button_state state);

	scalar<f32> input_mouse_delta(axis which);
	void input_mouse_delta_reset();
	void input_mouse_cursor(cursor_mode mode);
	void input_mouse_button(mouse_button button, button_state state);

	bool input_gamepad_connected(usize index);
	float input_gamepad_analog(usize index, gamepad_analog analog, axis which);
	bool input_gamepad_button(usize index, gamepad_button button, button_state state);

	usize time_current();
	usize time_tick_rate();
	usize time_one_second();

	void* window_handle();
	vector<2, i32> window_size();
	scalar<f32> window_scale();
	void window_title(const char* title);
	void window_fullscreen(bool engage);

	struct descriptor;
	using handle = const descriptor*;

	enum access_mode
	{
		FILE_READ,
		FILE_WRITE
	};

	handle file_open(const char* path, access_mode mode)
	{
	}

	enum seek_origin
	{
		SEEK_ORIGIN_START,
		SEEK_ORIGIN_END,
	};

	usize file_read(handle file, void* buffer, usize size);
	usize file_write(handle file, const void* buffer, usize size);
	void file_seek(handle file, usize offset, seek_origin origin);
	usize file_size(handle file);
	void file_close(handle file);
	bool file_exists(handle file);

	void system_log(const char* message);
	void system_alert(const char* title, const char* message);
}
